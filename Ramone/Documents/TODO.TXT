---------
Version 1
---------

URL Binding
  Template bindings
    string (path)  "/account/{user}"                [add base-url, bind params]
    string (url)   "http://dr.dk/{rss}/?day={day}"  [bind params]
    UriTemplate                                     [add base-url, bind params]

  Non-template bindings (simply adding ?x=1 to URL/path)
    string (path)  "/account"      [add base-url, add params]
    string (url)   "http://dr.dk"  [add params]
    URI                            [add params]

  Parameter inputs
    None (no templating)
    Typed objects: new { a = 1 }
    Hashtable
    IDictionary<string,string>
    NameValueCollection

  Return values
    RamoneRequest  [Bind()]
    Uri            [BindUri()]

  Method name ideas
    At()
    Bind()
    Request()


Session.Bind
- String(path) => Uri
- Uri + params (dictionary or objects) => "uri?params"
- Skelne mellem
    Bind => Uri ELLER Session.Uri(...)
    Request => Request (med param binding)

OAuth
- Reading callback URL from response
- Tænk på adskillelse mellem low-level signering af request og higj-level interaction med services.
- Encoding for ÆØÅ (Jørn Wildt)
- Gennemkommentere hele koden for Twitter access
- Aflæsning af urlencoded body
  - Vis i demo
- Skal kunne angive access_token direkte
- Logging af OAuth signature base mm. for debugging
  - callback method
  - Learn how to override the oauth_timestamp and oauth_nonce values in your OAuth library. 
    Use this capability to replay signature generation scenarios for comparative analysis.

Twitter:
- Ensure that your system's timestamp is in sync with Twitter's. We return the current time in the "Date" HTTP header with every request. If your request fails due to a timestamp mismatch, use this time to determine the delta between the system clock and our server clock and adjust your oauth_timestamps for subsequent requests accordingly.
- Defaults media types virker ikke rigtigt

Authorization as first-class citizens
- Interceptor pr. service (kan f.eks. have forskellige OAuth settings for forskellige services)
- Folk vil blive forvirret af "AuthenticationHandlers" (som jo altså ikke authentikerer ...)
- Standard implementations for OK:Basic, Digest, OAuth, NTLM and more
  - SimpleAuth (som sætter URL parametre ind https://github.com/restsharp/RestSharp/wiki/Authenticators)
      var client = new RestClient("http://example.com");
      client.Authenticator = new SimpleAuthenticator("username", "foo", "password", "bar");
      var request = new RestRequest("resource", Method.GET);
      client.Execute(request);
      The URL generated for this request would be http://example.com/resource?username=foo&password=bar

AsJson() osv. er ikke helt OK fordi det sjældet er begge veje der er det samme.

Undgå authorization exception - så kan man ikke aflæse body som normalt.

Serializing
  ObjectSerialiser, deserializing
  - Format specifiers for dot operators
  - Format specifiers for index operators

  FormUrlEncodingSerializer (plus json) deserialize til
  - OK: static type
  - dynamic type / expando
  - namevalue coll.
  - Encoding
  - dates, doubles, float, dictionaries, arrays, lists

  Serializer overloads that accepts streams and strings (not only readers)

  ReaderCodec for text/html (xml mf.) + string

  Can FormUrlEncodingSerializer (object serializeren) håndtere dynamics (Expando) og NameValueCollections?

Interceptors med "Context" argument (og ikke kun httprequest). Dvs. incl. session.

TextCodecBase
- WriteTo(object item, TextWriter writer, WriterContext context) => "item" findes nu i context

Ramone.HyperMedia
- OK: Link selector med media-type
- Tre forskellige koncepter på tværs af media-types (to "dimensioner": hyper-media / media-types)
  - OK: ILink
  - ILinkTemplate
  - IForm (key/value eller måske bare HTML specific med mulighed for genbrug i andre media-types)
    - SetInput(key, value), encoding etc.
    - Husk "hidden" og initial values for input
    - Submit()
- Og så diverse extension metoder til at aflæse sådanne elementer fra diverse formater
  - Konvertering fra [Xml|Html]Node til ILink etc.
  - Hvordan håndteres dynamic?
  - plus at kunne udvide det til nye formater
- OK: Follow(ILink), 
- Follow(ILinkTemplate, params)
- Make it possible to Follow() relative links.

Bind en ”non-template” URL med vilkårlige params:
  ”http://dr.dk” BIND { a = 1 & b = 2 } => ”http://dr.dk?a=1&b=2”

De generiske readers kunne også returnere NameValueCollection. Bør måske kunne styres?

Test scenarie hvor der returneres "NoContent" og man forsøger at hente content (skal give null)

- Demo how HTML + forms + url-encoded data can be auto-generated (a'la Eric)
  - Still missing a generic domain data embedding in HTML
    - Could be done as a "visitor" to the ObjectSerializer (like multipart/form-data and url-encoded)
  - Would be nice to see an html form autogenerated from code

Lots of Condition.Requries()...

Rename
- RamoneRequest/RamoneResponse => Request/Response
- IRamoneSession/Service => ISession, IService

Before releasing:
- Include a license
- Version numbers
- Komplet README (med korrekt casing)
  - Installation
- Demo 
  - Github
  - Ohloh
  - Google pages
  - Dropbox
  - ITunes search
  - del.icio.us
  - YouTube
  - Google weather
  - Facebook Graph
  - NerdDinner
  - Twitter
  - Flickr

Docs
- Ramone 
  - Focus on RESTful patterns
  - Er godt for object serialization (pas på med dette udsagn)
  - Samler en række forskellige media types på ét sted
- OAuth + Basic authorization
- Alle Get/Post etc. operationer er uden sideeffekter i RamoneRequest. 
  Altså kan RamoneRequest genbruges flere gange. Eller hvad ...
- Go through REST reciepes and show how its done in Ramone
- Forsøger at "tvinge" REST igennem. F.eks. ved
  - Indbygget support for hyper-media controls i forskellige formater
  - At skelne mellem media type codecs og serializere
  - Antager ikke at man KUN kan lave 1-1 serialisering med XML/JSON, men anvender derimod codecs.
  - Kun at arbejde med get/post etc. Ingen support for navngivne metoder som f.eks. "GetOrders".
- Response.Created() laver evt. GET på location
- How to debug using Fiddler and local machine name (not "localhost"!)

Serializer settings for OpenRasta


---------
Version 2
---------

System.Net.Mime.MimeType ... der var parseren. Tænkte nok det fandtes allerede.

Conditional Delete, Get, etc.

Caching
- Er det smart eller skal man forvente en proxy? Det sikkert svært at få korrekt.
- Findes det allerede i .NET eller som open source
- Skal det laves med Sqlite?
- Er det pr. session eller hvad?

Support for quality "q" param in accept header and codec selector

Compression
- As some kind of "pipeline" contributor
  - Wrapping incoming stream in another stream (zip for instance)

Set referrer
- Manually
- Automatically when using Follow()

Specifying what the default codec is for a type (so Accept need not be set)
- Især for application/xml (som også genkender text/xml)
- Man kan få multiple writers for XmlDocument (application/xml og text/xml ... hvad med application/xhtml+xml mf.?) 
  - Der er behov for at prioritere hvilken der skal vælges ved skrivning (og læsning/accept)
  - q=x.x (quality priority)

IService
- A place to specify additional headers that should always be included (like a API version number)
  - A shorthand for an interceptor

Charset Encoding skal sættes som en default værdi i session/service/config

Predefined codecs
- Any content as a string
- Images

Retrying (if idempotent = user defined)
  request.Retry(3[optional]).Post<x>(y);

Gennemtænk scenarier for redirects (ved både GET og POST/PUT)
- Hvordan spiller det med Response.Created()
- Noget med at hooke ind i redirects
  - Case c = req.Get<Case>() ... ved automatisk redirect virker det, men vil man gerne vide at det er sket?
  - Opsætning på både session, service/client os.

Hardcoded test URL into config


---------
Version N
---------

UrlEncoded serialisering direkte til URL (når man ikke anvender URL templates)
- Request r = Session.Request("http://xxx.yy", new { a= 1 }) => "http://xxx.yy?a=1"

Kan der være en fordel i at lave en Multipart/form-data og url-encoded "formatter" 
- Noget a'la en stream hvor man kan lave formatter.WriteParameter(key, value)
- Findes der noget i System.Net[.Mime]?

Async style
- http://xamlcoder.com/blog/2011/01/23/consuming-wcf-web-rest-apis-in-silverlight/
  var task = client.SendAsync(request);
  task.ContinueWith(t => ...)

- More codecs
  - vCard (kan Xyperico udgaven dresseres til at ligne XmlSerializer i .NET?)
  - Protocol buffers
  - HAL
  - RDFa
  - RSS
  - oData


